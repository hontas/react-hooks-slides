import { Head } from 'mdx-deck';
import { LiveCode } from 'mdx-deck-live-code';
import { CodeSurfer } from 'mdx-deck-code-surfer';
import dracula from 'prism-react-renderer/themes/dracula';
import providerProps from './lib/providerProps';
export { default as theme } from './theme';
import 'style-loader!css-loader!./styles/base.css';

<Head>
  <title>React hooks</title>
</Head>

# React hooks

---

## Agenda

- What hooks are...
- use[State|Effect|Context]
- other hooks
- custom hooks
- testing hooks
- rules of hooks
- summary

---

# Like mixins but...

- they allow passing state from one to another.
- it's explicit where logic is coming from.

[hooks in vue.js](https://css-tricks.com/what-hooks-mean-for-vue)

---

# Hooks let us...

- reuse component logic without changing hierarchy
- split one component into smaller functions based on what pieces are related
- use React without classes üòÜ‚ù§Ô∏è

[docs: hooks motivation](https://reactjs.org/docs/hooks-intro.html#motivation)

```notes
- resuse: no more "HOC hell"
- split: related code together
- no class: everybodys happy!
```

---

## use State

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseStateClass.js')}
/>

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseStateHook.js')}
  providerProps={providerProps}
/>

```notes
- setState(value)
- setState(prev => nextValue)
- setState(prev => ({ ...prev, update }))
```

---

## use Effect

- componentDidMount
- componentDidUpdate
- componentWillUnmount

```notes
like the above API's but not synchronous -> impacts timing and tests
```

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseEffectClass.js')}
/>

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseEffectHook.js')}
  providerProps={providerProps}
/>

---

# The curious case of setInterval

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseInterval.js')}
  providerProps={providerProps}
/>

---

## use Context

---

<CodeSurfer
  lang="javascript"
  theme={dracula}
  code={require('!raw-loader!./context/LocaleContextHook.js')}
  providerProps={providerProps}
/>

---

<LiveCode
  size="fullscreen"
  providerProps={providerProps}
  code={require('!raw-loader!./components/UseContextComp.js')}
  providerProps={providerProps}
/>

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseContextHook.js')}
  providerProps={providerProps}
/>

---

<CodeSurfer
  lang="javascript"
  theme={dracula}
  title="Other hooks"
  code={require('!raw-loader!./components/OtherHooks.js')}
/>

---

# Instance variables

---

<LiveCode
  size="fullscreen"
  code={require('!raw-loader!./components/UseRefHook.js')}
  providerProps={providerProps}
/>

---

## Custom hooks

Easily share and test reusable logic

---

<CodeSurfer
  lang="javascript"
  theme={dracula}
  title="Custom hook"
  code={require('!raw-loader!./lib/customHook.js')}
/>

---

<LiveCode
  size="fullscreen"
  title="Custom hook"
  code={require('!raw-loader!./components/UseCustomHook.js')}
  providerProps={providerProps}
/>

---

## Testing

As long as you dont depend on implementation details in your tests - `there should be no difference`‚Ñ¢

---

<CodeSurfer
  title="Testing effect"
  lang="javascript"
  code={require('!raw-loader!./components/TestEffectHook.js')}
/>

---

# Hooks let us...

- reuse component logic without changing hierarchy
- split one component into smaller functions based on what pieces are related
- use React without classes üòÜ‚ù§Ô∏è

[tweet: related code](https://twitter.com/threepointone/status/1056594421079261185)

[tweet: hooks minification](https://twitter.com/jamiebuilds/status/1056015484364087297)

---

## Hooked? üòå
